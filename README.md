
# iOS 23种设计模式（附 DEMO）

原创大神 GitHub [地址](https://github.com/huang303513/Design-Pattern-For-iOS)

## 1.简单工厂模式(Factory)

专门定义一个类，用来实例化其他的类，被创建的父类尝尝拥有共同的父类


## 2.工厂模式(Factory)
定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。相对于简单工厂方法，工厂方法模式把工厂也抽象出来，进行接口、实现分离。这样具体工厂和具体产品可以对应着同时扩充，而不需要修改现有逻辑。当然，使用者也许在不同场景要在一定程度上自己对应的工厂选择。


## 3.装饰模式（Decorator）

装饰模式好比给一个对象赋予新的特征，Python 中也有装饰模式，比如我们现在做的饭一样，做饭只是一个笼统的说法，我们可以做蛋糕，做牛排，给做饭添加装饰，就可以装饰城做蛋糕，相比添加子类，装饰模式将更加的灵活,比如扩展和类别就是装饰模式

```
SCXBaseComponent *component = [SCXBaseComponent new];
    SCXComponentDecorator *dec1 = [SCXComponentDecorator new];
    SCXComponentDecoratorA *dec2 = [SCXComponentDecoratorA new];
    dec1.component = component;
    dec2.component = component;
    [dec1 work];
    [dec2 work];

```

component 是基本组件，基本方法实现，dec1 和 dec2，是对基本组件的装饰，比如之前是做饭，经过装饰之后就是做蛋糕之类的，详细看代码。


## 4.策略模式（Strategy）

策略模式定义并封装了不同的算法家族，他们之间可以相互替换，通过不同的指向，实现不同的算法，和工厂模式非常的相似，如果配合工厂模式，传入不同的type就会产生不同的工厂，不同的工厂有不同的算法，同样的入口，返回不同的结果

其实策略模式和工厂模式真的很想，很容易混淆，那么他们有什么差别呢，工厂模式，属于创建性模式，他的作用是创建对象，相当于一个黑盒子，创建完了，你干什么我不管，而策略模式和行为性模式，它是对一个对象的多种行为，选择一种行为，选择一种算法，算法之间可以相互替换，工厂模式关注的是对象的创建，策略模式关注的是行为的封装。

## 5.代理模式 (proxy)

我们最常见的代理模式，就是我们使用的 `tableVIew` 的 DataSource 和 delegate,为其他对象提供一种代理以控制这个对象的访问

比如说 我们现在有个商店类，卖花，卖茶，卖蛋糕，这时候，我们其他很多用户都有自己的商品，但是商品又不能自己卖自己，那怎么办呢，我们=通过人把商品代理给商店，这样商品就可以卖出去了，人就起一个中间代理的作用，同时，买东西也是一种代理，棒住商品卖出去。

## 6.模板模式（Template）

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

比如说，我们常见的问问题回答问题，问题属于通用的模板，就一个问题，而回答可能千遍万化，也可能从题库里随机生成题，但是题目的生成都成能通过某种算法从题库里面选择出来，这时候题可以作为一个通用的模板算法，而回答问题，可以延迟到子类里面，在子类里面来冲定义某算法的某个步骤，就是生成答案。

## 7.外观模式(Facade)

外观模式，就是为子系统定义一个高层接口，这个借口是得这一子系统更加容易使用

比如我们京东卖东西一样，用户来买东西，不需要管你的售前售中售后，我只是来买东西，然后付款就行，对于客户来说，唯一不同的就是直接支付还是白条支付，而对于用户来说，只有一个买东西，然后点击付款，之间的，包装发货和我无关，所以只需要一个卖东西的高层接口就足够了.

## 8.建造者模式（builder）

将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示，它可以将复杂对象的构建过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同的对象。

例如我们买苹果手机一样，我们只需要买手机就可以，而手机的建造过过程我们不需要知道的，买手机，手机的整体制造不一定都是由一个厂家制造，比如屏幕、芯片等。当做手机的时候，就是一个建造者模式，分给屏幕厂家和芯片厂家来建造，而屏幕厂家制作屏幕的时候，某个零件又有别的常见来建造，有事一个新的建造者模式，而这些对于我们来说都无须理会，而对于手机制造商来说，比如手机只有两部分，屏幕和芯片，那么手机制造商第一一个建造者模式，屏幕和芯片，分配下去就好了.

## 9.原型模式（ProtoType）

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。ios 中的原型模式需要遵守 NSCoping 协议，比如我们 ios 中的数组。

## 10.观察者模式（Observer）
定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。这种模式就不用说了吧，我们 ios 中的KVO，NSNitification 都是观察者模式。

## 11.状态模式（State）

当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类

## 12.适配器模式

适配器主要用于将一些由于接口不兼容而导致一些类不能在一起使用，从而通过适配器来让他们能够工作，主要用于，复用现有的类，但接口由于现有环境不一致.

## 13.备忘录模式

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态

在不改变原有封装性的前提下，在对象之外保存对象的状态，这样可以将对象回复到原来的状态，比如 ios 的归档解档
比如我们玩 LOL ，其实都给一些零用钱给你买多蓝盾、多兰戒和血瓶，这是最初始的任务状态，然后就把任务给分配出去打架，赚更多的钱，买更多的装备，击败更多的敌人，但游戏结束，重新报开始的时候又回到了最初的模式，那么可以将这样理解为备忘录状态，无论你人物出去怎么浪，我备注一下你初始的状态，最后你还是会回来的。


## 13.组合模式

将对象组合成树状结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和整体的使用具有一致性。